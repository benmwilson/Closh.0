// closh.c - COSC 315, Winter 2021
// Richardo Brown

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/wait.h>

#define TRUE 1
#define FALSE 0

// tokenize the command string into arguments - do not modify
void readCmdTokens(char* cmd, char** cmdTokens) {
    cmd[strlen(cmd) - 1] = '\0'; // drop trailing newline
    int i = 0;
    cmdTokens[i] = strtok(cmd, " "); // tokenize on spaces
    while (cmdTokens[i++] && i < sizeof(cmdTokens)) {
        cmdTokens[i] = strtok(NULL, " ");
    }
}

// read one character of input, then discard up to the newline - do not modify
char readChar() {
    char c = getchar();
    while (getchar() != '\n');
    return c;
}

// main method - program entry point
int main() {
    char cmd[81]; // array of chars (a string)
    char* cmdTokens[20]; // array of strings
    int count; // number of times to execute command
    int parallel; // whether to run in parallel or sequentially
    int timeout; // max seconds to run set of commands (parallel) or each command (sequentially)
    
    while (TRUE) { // main shell input loop
        
        // begin parsing code - do not modify
        printf("closh> ");
        fgets(cmd, sizeof(cmd), stdin);
        if (cmd[0] == '\n') continue;
        readCmdTokens(cmd, cmdTokens);
        do {
            printf("  count> ");
            count = readChar() - '0';
        } while (count <= 0 || count > 9);
        
        printf("  [p]arallel or [s]equential> ");
        parallel = (readChar() == 'p') ? TRUE : FALSE;
        do {
            printf("  timeout> ");
            timeout = readChar() - '0';
        } while (timeout < 0 || timeout > 9);
        // end parsing code
        
        
        ////////////////////////////////////////////////////////
        //                                                    //
        // TODO: use cmdTokens, count, parallel, and timeout  //
        // to implement the rest of closh                     //
        //                                                    //
        // /////////////////////////////////////////////////////
        

int point = 1;
int pids[count];
int process_ID;
double time_elapsed;

if (parallel == 0){
for (int i=1; i<count+1; i++){
    
    printf("%d: Parent (pid:%d)\n Child (pid:%d)\n",(int)point ,(int)getppid(), (int) getpid());
    process_ID = fork();
    
    if(process_ID < 0) {
    // fork failed
    printf("Can't execute %s\n", cmdTokens[i]);
    }
    // process timer
    clock_t process_time;
    process_time = clock();

    if(process_ID == 0) {
     // child (new process)
        printf("%d: Child (pid:%d)\n", (int)i, (int)getpid());
        execvp( cmdTokens[0], cmdTokens);
    } 
    else if(process_ID >0){ // Parents' root
        // Calling the wait system call to create new process
        printf("Child process in progress.\n");

        while(waitpid(process_ID, NULL, WNOHANG) == 0){
            process_time = clock()- process_time;
            double time_elapsed = ((double)process_time)/CLOCKS_PER_SEC;
            
            if(timeout != 0 & time_elapsed >= timeout){
            // Since it is beyond the timeout at this stage, kill process.
                printf("Timeout elapsed is %f\n", (float)time_elapsed);
                kill(process_ID, SIGKILL);
                printf("child process killed\n");
                    break;
                }
        }
     } 
     point++;
    }
    exit(1);
   }
   else if(parallel == 1){
       for (int i=1; i<count+1; i++){
           printf("%d: Parent (pid:%d)\n Child (pid:%d)",(int)point ,(int)getppid(), (int)getpid());
           process_ID = fork();
           clock_t process_timep;
           if(process_ID < 0) {
           // fork failed
           printf("Can't execute %s\n", cmdTokens[i]);
           }

           if(process_ID == 0){
               // process timer
                process_timep = clock();
                printf("%d: Child (pid:%d)\n", (int)i, (int)getpid());
                execvp( cmdTokens[i], cmdTokens);
                
          }else if(process_ID >0){ // Parent process at root
               int pids[count];
               pids[point] = process_ID;
               while(process_ID != 0){
                double time_elapsed = ((double)process_timep)/CLOCKS_PER_SEC;

                if(timeout != 0 & time_elapsed <= timeout){
                  for(int k =1; k<count+1;k++){
                     printf("The Child (pid:%d) is in position %d\n", pids[k], (int)k);
                     process_ID = pids[k];
                     // Calling the wait system call  to create new process
                     if(waitpid(process_ID, NULL, WNOHANG) == 0){
                        // Since it is beyond the timeout at this stage, kill process.
                        printf("Timeout elapsed is %f\n", (float)time_elapsed);
                        kill(process_ID, SIGKILL);
                        printf("child process killed\n");
                        break;
                        }
                    }
                } 
            }
        } 
        exit(1);   
    }
   point++;
 exit(1);
  }
 }
}
